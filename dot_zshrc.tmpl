# ============================================================
# zsh - Optimized cross-platform shell (macOS + WSL Ubuntu)
# Security-focused for MSSP/SOC work
# Machine type: {{ if .isWork }}WORK{{ else }}PERSONAL{{ end }}
# ============================================================

# ----------------------------
# Safety + history hygiene
# ----------------------------
export HISTFILE="$HOME/.zsh_history"
export HISTSIZE=100000
export SAVEHIST=100000
setopt SHARE_HISTORY
setopt INC_APPEND_HISTORY
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE
setopt EXTENDED_HISTORY
setopt HIST_REDUCE_BLANKS

# Tip: prefix secret commands with a space to avoid history.

# ----------------------------
# Fast, predictable PATH
# ----------------------------
typeset -U path PATH

# Add local bin to PATH
path=("$HOME/.local/bin" $path)
export PATH

# ----------------------------
# Editor
# ----------------------------
export EDITOR="code --wait"
export VISUAL="code --wait"
export PAGER="less -FRX"

# ----------------------------
# XDG base (keeps config tidy)
# ----------------------------
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# ----------------------------
# WSL2-specific fixes
# ----------------------------
if grep -qi microsoft /proc/version 2>/dev/null; then
  # Fix DNS issues
  export WSL_DNS_FIX=true
  
  # Windows interop helpers
  alias explorer='explorer.exe'
  alias codewin='code.exe'
fi

# ----------------------------
# Mise: runtime versions (node/python/etc.)
# ----------------------------
if command -v mise >/dev/null 2>&1; then
  eval "$(mise activate zsh)"
fi

# ----------------------------
# Starship prompt (context awareness)
# ----------------------------
if command -v starship >/dev/null 2>&1; then
  eval "$(starship init zsh)"
fi

# ----------------------------
# direnv: project environment + secrets injection
# ----------------------------
if command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi

# ----------------------------
# zoxide: smarter cd
# ----------------------------
if command -v zoxide >/dev/null 2>&1; then
  eval "$(zoxide init zsh)"
  alias cd='z'
fi

# ----------------------------
# fzf: fuzzy everything
# ----------------------------
if [ -f "$HOME/.fzf.zsh" ]; then
  source "$HOME/.fzf.zsh"
fi

# Better fzf defaults
export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border'
export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'

# ----------------------------
# Better defaults: modern tools
# ----------------------------
if command -v eza >/dev/null 2>&1; then
  alias ls='eza --group-directories-first --icons'
  alias ll='eza -la --group-directories-first --icons'
  alias lt='eza --tree --level=2 --icons'
else
  alias ll='ls -la'
fi

if command -v bat >/dev/null 2>&1; then
  alias cat='bat --style=auto'
  export BAT_THEME="Monokai Extended"
fi

# Ubuntu: fd is fdfind
if command -v fdfind >/dev/null 2>&1 && ! command -v fd >/dev/null 2>&1; then
  alias fd='fdfind'
fi

# Use ripgrep for grep
if command -v rg >/dev/null 2>&1; then
  alias grep='rg'
fi

# ----------------------------
# Guard rails (interactive only)
# ----------------------------
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'

# ----------------------------
# Quick navigation
# ----------------------------
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias reload='exec zsh'

# ----------------------------
# Git power aliases
# ----------------------------
alias g='git'
alias gs='git status -sb'
alias ga='git add'
alias gd='git diff'
alias gds='git diff --staged'
alias gc='git commit'
alias gca='git commit --amend'
alias gl='git pull --rebase'
alias gp='git push'
alias gco='git checkout'
alias gb='git branch'
alias gcl='git clone'
alias glog='git log --oneline --graph --decorate'

# Fuzzy checkout (local + remote)
gcb() {
  local branch
  branch="$(git branch --all --format='%(refname:short)' 2>/dev/null | sed 's#^remotes/##' | sort -u | fzf)"
  [ -n "$branch" ] && git checkout "$branch"
}

# ----------------------------
# Ansible power tools
# ----------------------------
alias av='ansible-vault'
alias ap='ansible-playbook --diff'
alias aping='ansible all -m ping'
alias alint='ansible-lint'
alias agalaxy='ansible-galaxy'

# Vault editing helper (uses EDITOR)
ave() {
  ansible-vault edit "${1:?usage: ave <file>}"
}

# Quick vault view
avv() {
  ansible-vault view "${1:?usage: avv <file>}"
}

{{- if .isPersonal }}
# Run playbook with vault password from 1Password (PERSONAL ONLY)
ap-op() {
  local vault_item="${OP_ANSIBLE_VAULT:-ansible-vault}"
  if command -v op >/dev/null 2>&1; then
    ansible-playbook --vault-password-file=<(op read "op://Private/$vault_item/password") "$@"
  else
    echo "‚ùå 1Password CLI not available"
    return 1
  fi
}
{{- else }}
# Run playbook with vault password from file (WORK)
ap-vault() {
  local vault_file="${1:-.vault_pass}"
  shift
  ansible-playbook --vault-password-file="$vault_file" "$@"
}
{{- end }}

# Check Ansible syntax
acheck() {
  ansible-playbook --syntax-check "${1:?usage: acheck <playbook.yml>}"
}

# ----------------------------
# Kubernetes essentials
# ----------------------------
alias k='kubectl'

# kubectx/kubens if installed
if command -v kubectx >/dev/null 2>&1; then
  alias kx='kubectx'
  alias kn='kubens'
fi

# Quick context switch with fzf
kctx-fzf() {
  local context
  context=$(kubectl config get-contexts -o name | fzf --height=10 --prompt="K8s context: ")
  [ -n "$context" ] && kubectl config use-context "$context"
}

# Quick namespace switch with fzf
kns-fzf() {
  local ns
  ns=$(kubectl get ns -o name | sed 's#namespace/##' | fzf --height=10 --prompt="Namespace: ")
  [ -n "$ns" ] && kubectl config set-context --current --namespace="$ns"
}

# Show current K8s context clearly (sanity check before running commands)
kwhere() {
  echo "Context:   $(kubectl config current-context)"
  echo "Namespace: $(kubectl config view --minify --output 'jsonpath={..namespace}')"
  echo "Server:    $(kubectl config view --minify --output 'jsonpath={..cluster.server}')"
}

# Common kubectl shortcuts
alias kgp='kubectl get pods'
alias kgs='kubectl get svc'
alias kgn='kubectl get nodes'
alias kdp='kubectl describe pod'
alias kl='kubectl logs'
alias klf='kubectl logs -f'

# ----------------------------
# Docker / Compose
# ----------------------------
alias d='docker'
alias dc='docker compose'
alias dps='docker ps'
alias dpsa='docker ps -a'
alias dcu='docker compose up'
alias dcd='docker compose down'
alias dlog='docker logs -f'
alias dex='docker exec -it'

# ----------------------------
# Ports / processes
# ----------------------------
ports() {
  lsof -i -P -n | head -n 40
}

psg() {
  ps aux | rg -i "${1:?usage: psg <pattern>}"
}

# Kill process on port
killport() {
  local port="${1:?usage: killport <port>}"
  lsof -ti:$port | xargs kill -9
}

{{- if .isPersonal }}
# ----------------------------
# 1Password helpers (PERSONAL MACHINES ONLY)
# ----------------------------
# Helper to list 1Password items
op-list-work() {
  if command -v op >/dev/null 2>&1; then
    op item list --vault Work --format json | jq -r '.[].title' | sort
  else
    echo "‚ùå 1Password CLI not installed"
  fi
}

op-list-personal() {
  if command -v op >/dev/null 2>&1; then
    op item list --vault Private --format json | jq -r '.[].title' | sort
  else
    echo "‚ùå 1Password CLI not installed"
  fi
}

# Quick read from 1Password
op-read() {
  local item="${1:?usage: op-read <item-reference>}"
  if command -v op >/dev/null 2>&1; then
    op read "$item"
  else
    echo "‚ùå 1Password CLI not installed"
    return 1
  fi
}
{{- end }}

# ----------------------------
# Security scanning before commits
# ----------------------------
alias scan-secrets='gitleaks detect --no-git'
alias scan-ansible='checkov -d . --framework ansible'
alias scan-docker='trivy fs .'

# Quick pre-push safety check
safety-check() {
  echo "üîç Scanning for secrets..."
  gitleaks detect --no-git --verbose || return 1
  
  if command -v trivy >/dev/null 2>&1; then
    echo "üîç Scanning for vulnerabilities..."
    trivy fs --security-checks vuln,config,secret . || return 1
  fi
  
  echo "‚úÖ Safety checks passed"
}

# ----------------------------
# Customer environment awareness (CRITICAL FOR MSSP!)
# ----------------------------
# Set customer context (updates both direnv and prompt)
set-customer() {
  local customer="${1:?usage: set-customer <name>}"
  export CUSTOMER_CONTEXT="$customer"
  echo "üè¢ Customer context: $customer"
}

# Clear customer context
unset-customer() {
  unset CUSTOMER_CONTEXT
  echo "üîì Customer context cleared"
}

# Show current customer context
show-customer() {
  if [ -n "${CUSTOMER_CONTEXT:-}" ]; then
    echo "üè¢ Current customer: $CUSTOMER_CONTEXT"
  else
    echo "No customer context set"
  fi
}

# ----------------------------
# Work/private switching helpers
# ----------------------------
{{- if .isPersonal }}
workon() {
  cd "$HOME/work" 2>/dev/null || { echo "~/work not found"; return 1; }
}

homeon() {
  cd "$HOME" || return 1
}
{{- end }}

# ----------------------------
# Infra context helpers (AWS/GCP/Azure)
# ----------------------------
awswho() {
  command -v aws >/dev/null 2>&1 || { echo "aws CLI not found"; return 1; }
  aws sts get-caller-identity --output json | jq
}

# ----------------------------
# AI command integration (Claude Code / Codex CLI)
# ----------------------------
_ai_pick() {
  if command -v claude >/dev/null 2>&1; then
    echo "claude"
    return 0
  fi
  if command -v codex >/dev/null 2>&1; then
    echo "codex"
    return 0
  fi
  return 1
}

ai() {
  local tool
  tool="$(_ai_pick)" || { echo "No AI CLI found (expected: claude or codex)"; return 1; }
  if [ -t 0 ]; then
    "$tool" "$@"
  else
    cat | "$tool" "$@"
  fi
}

# Explain last command failure quickly
ai-explain-last() {
  local last
  last="$(fc -ln -1)"
  printf "%s\n\n%s\n" "Explain what this command does and why it might fail:" "$last" | ai
}

# Generate commit message from staged diff
ai-commit-msg() {
  git diff --staged | ai "Write a concise, imperative mood git commit message for this change. Output ONLY the subject line."
}

# Convert natural language to a safe shell command (review before running)
ai-cmd() {
  local prompt="${1:?usage: ai-cmd 'describe command'}"
  printf "%s\n" "Write a safe shell command for: $prompt. Output ONLY the command." | ai
}

# ----------------------------
# Utility functions
# ----------------------------
# Extract any archive
extract() {
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar x "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "'$1' cannot be extracted" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Create directory and cd into it
mkcd() {
  mkdir -p "$1" && cd "$1"
}

# Quick HTTP server
serve() {
  local port="${1:-8000}"
  python3 -m http.server "$port"
}

# Find files by name
ff() {
  fd -H -I -t f "$1"
}

# Find directories by name
fdir() {
  fd -H -I -t d "$1"
}

# ----------------------------
# Machine-specific indicator
# ----------------------------
{{- if .isWork }}
# Work machine configuration loaded
export MACHINE_TYPE="work"
{{- else }}
# Personal machine configuration loaded
export MACHINE_TYPE="personal"
{{- end }}

# ----------------------------
# Load local overrides (not committed)
# ----------------------------
[ -f ~/.zshrc.local ] && source ~/.zshrc.local
